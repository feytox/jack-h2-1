/** Класс, отвечающий за типы блоков. */
class Block {
    static Block air;
    static Block stone;
    static Block coin;
    static Block key;
    static Block finish;

    static Block spikesUp;
    static Block spikesRight;
    static Block spikesDown;
    static Block spikesLeft;

    field boolean _moveThrough;

    constructor Block new(boolean moveThrough){
        let _moveThrough = moveThrough;
        return this;
    }

    /** Инициализирует типы блоков */
    function void initBlocks(){
        let air = Block.new(true);
        let stone = Block.new(false);
        let coin = Block.new(true);
        let key = Block.new(true);
        let finish = Block.new(true);

        let spikesUp = Block.new(true);
        let spikesRight = Block.new(true);
        let spikesDown = Block.new(true);
        let spikesLeft = Block.new(true);
        return;
    }

    /** Парсит блок из символа */
    function Block parse(char blockChar){
        if ((blockChar = 32) | (blockChar = 80)){ // ' ' or 'P' = air
            return air;
        }

        if (blockChar = 35){ // '#' = stone
            return stone;
        }

        if (blockChar = 67){ // 'C' = coin
            return coin;
        }

        if (blockChar = 75){ // 'K' = key
            return key;
        }

        if (blockChar = 70){ // 'F' = finish
            return finish;
        }

        if (blockChar = 87){ // 'W' = spikesUp
            return spikesUp;
        }

        if (blockChar = 69){ // 'E' = spikesRight
            return spikesRight;
        }

        if (blockChar = 82){ // 'R' = spikesDown
            return spikesDown;
        }

        if (blockChar = 84){ // 'T' = spikesLeft
            return spikesLeft;
        }

        do Exception.throw("Block: invalid block");
        return 0;
    }

    method void onStepped(Level level, Map map, int x, int y){
        var Score score;

        if (this = coin){
            let score = level.getScore();
            do score.IncrementCoins();
            do map.removeBlock(x, y);
        }
        if (this = key){
            let score = level.getScore();
            do score.IncrementKeys();
            do map.removeBlock(x, y);
        }
        if (this = finish){ // TODO next level

            do map.removeBlock(x,y);
        }
        if (this = spikesUp){ // TODO restart level
            let score = level.getScore();
            do score.ResetScore();
        }

        return;
    }

    /** Отрисовывает блок с учётом координаты левого края и размеров */
    method void render(int x, int y, int width, int height){
        // TODO: убрать размеры, они бесполезны
        var int memAddress;
        let memAddress = 16384 + (y * 32) + (x / 16);

        if (this = stone){
            do _renderFull(memAddress);
        }
        if (this = coin){
            do _renderCoin(memAddress);
        }
        if (this = key){
            do _renderKey(memAddress);
        }
        if (this = finish){
            do _renderFinish(memAddress);
        }
        if (this = spikesUp){
            do _renderSpikesUp(memAddress);
        }
        if (this = spikesRight){
            do _renderSpikesRight(memAddress);
        }
        if (this = spikesDown){
            do _renderSpikesDown(memAddress);
        }
        if (this = spikesLeft){
            do _renderSpikesLeft(memAddress);
        }
        return;
    }

    /** Рендерит полностью закрашенный квадрат */
    method void _renderFull(int memAddress){
        do Memory.poke(memAddress + 0, -1);
        do Memory.poke(memAddress + 32, -1);
        do Memory.poke(memAddress + 64, -1);
        do Memory.poke(memAddress + 96, -1);
        do Memory.poke(memAddress + 128, -1);
        do Memory.poke(memAddress + 160, -1);
        do Memory.poke(memAddress + 192, -1);
        do Memory.poke(memAddress + 224, -1);
        do Memory.poke(memAddress + 256, -1);
        do Memory.poke(memAddress + 288, -1);
        do Memory.poke(memAddress + 320, -1);
        do Memory.poke(memAddress + 352, -1);
        do Memory.poke(memAddress + 384, -1);
        do Memory.poke(memAddress + 416, -1);
        do Memory.poke(memAddress + 448, -1);
        do Memory.poke(memAddress + 480, -1);
        return;
    }

    method void _renderCoin(int memAddress){
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 960);
        do Memory.poke(memAddress + 64, 4080);
        do Memory.poke(memAddress + 96, 7224);
        do Memory.poke(memAddress + 128, 15324);
        do Memory.poke(memAddress + 160, 12876);
        do Memory.poke(memAddress + 192, 25158);
        do Memory.poke(memAddress + 224, 25542);
        do Memory.poke(memAddress + 256, 24646);
        do Memory.poke(memAddress + 288, 24646);
        do Memory.poke(memAddress + 320, 12364);
        do Memory.poke(memAddress + 352, 14428);
        do Memory.poke(memAddress + 384, 7224);
        do Memory.poke(memAddress + 416, 4080);
        do Memory.poke(memAddress + 448, 960);
        do Memory.poke(memAddress + 480, 0);
        return;
    }

    method void _renderKey(int memAddress) {
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 0);
        do Memory.poke(memAddress + 96, 0);
        do Memory.poke(memAddress + 128, 0);
        do Memory.poke(memAddress + 160, 28);
        do Memory.poke(memAddress + 192, 38);
        do Memory.poke(memAddress + 224, 13814);
        do Memory.poke(memAddress + 256, 32766);
        do Memory.poke(memAddress + 288, 62);
        do Memory.poke(memAddress + 320, 28);
        do Memory.poke(memAddress + 352, 0);
        do Memory.poke(memAddress + 384, 0);
        do Memory.poke(memAddress + 416, 0);
        do Memory.poke(memAddress + 448, 0);
        do Memory.poke(memAddress + 480, 0);
        return;
    }

     method void _renderFinish(int memAddress) {
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 16380);
        do Memory.poke(memAddress + 96, 11468);
        do Memory.poke(memAddress + 128, 11468);
        do Memory.poke(memAddress + 160, 13116);
        do Memory.poke(memAddress + 192, 13116);
        do Memory.poke(memAddress + 224, 11468);
        do Memory.poke(memAddress + 256, 11468);
        do Memory.poke(memAddress + 288, 13116);
        do Memory.poke(memAddress + 320, 13116);
        do Memory.poke(memAddress + 352, 11468);
        do Memory.poke(memAddress + 384, 11468);
        do Memory.poke(memAddress + 416, 16380);
        do Memory.poke(memAddress + 448, 12);
        do Memory.poke(memAddress + 480, 12);
        return;
    }

    method void _renderSpikesUp(int memAddress){
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 0);
        do Memory.poke(memAddress + 96, 0);
        do Memory.poke(memAddress + 128, 0);
        do Memory.poke(memAddress + 160, 0);
        do Memory.poke(memAddress + 192, 0);
        do Memory.poke(memAddress + 224, 0);
        do Memory.poke(memAddress + 256, 8456);
        do Memory.poke(memAddress + 288, 8456);
        do Memory.poke(memAddress + 320, 29596);
        do Memory.poke(memAddress + 352, 29596);
        do Memory.poke(memAddress + 384, 32766);
        do Memory.poke(memAddress + 416, -1);
        do Memory.poke(memAddress + 448, -1);
        do Memory.poke(memAddress + 480, -1);
        return;
    }

    method void _renderSpikesRight(int memAddress){
        do Memory.poke(memAddress + 0, 7);
	do Memory.poke(memAddress + 32, 15);
	do Memory.poke(memAddress + 64, 63);
	do Memory.poke(memAddress + 96, 255);
	do Memory.poke(memAddress + 128, 63);
	do Memory.poke(memAddress + 160, 15);
	do Memory.poke(memAddress + 192, 15);
	do Memory.poke(memAddress + 224, 63);
	do Memory.poke(memAddress + 256, 255);
	do Memory.poke(memAddress + 288, 63);
	do Memory.poke(memAddress + 320, 15);
	do Memory.poke(memAddress + 352, 15);
	do Memory.poke(memAddress + 384, 63);
	do Memory.poke(memAddress + 416, 255);
	do Memory.poke(memAddress + 448, 63);
	do Memory.poke(memAddress + 480, 7);
	return;
    }

    method void _renderSpikesDown(int memAddress){
        do Memory.poke(memAddress + 0, -1);
	do Memory.poke(memAddress + 32, -1);
	do Memory.poke(memAddress + 64, -1);
	do Memory.poke(memAddress + 96, 32766);
	do Memory.poke(memAddress + 128, 14798);
	do Memory.poke(memAddress + 160, 14798);
	do Memory.poke(memAddress + 192, 4228);
	do Memory.poke(memAddress + 224, 4228);
	do Memory.poke(memAddress + 256, 0);
	do Memory.poke(memAddress + 288, 0);
	do Memory.poke(memAddress + 320, 0);
	do Memory.poke(memAddress + 352, 0);
	do Memory.poke(memAddress + 384, 0);
	do Memory.poke(memAddress + 416, 0);
	do Memory.poke(memAddress + 448, 0);
	do Memory.poke(memAddress + 480, 0);
	return;
    }

    method void _renderSpikesLeft(int memAddress){
        do Memory.poke(memAddress + 0, -8192);
	do Memory.poke(memAddress + 32, -1024);
	do Memory.poke(memAddress + 64, -256);
	do Memory.poke(memAddress + 96, -1024);
	do Memory.poke(memAddress + 128, -4096);
	do Memory.poke(memAddress + 160, -4096);
	do Memory.poke(memAddress + 192, -1024);
	do Memory.poke(memAddress + 224, -256);
	do Memory.poke(memAddress + 256, -1024);
	do Memory.poke(memAddress + 288, -4096);
	do Memory.poke(memAddress + 320, -4096);
	do Memory.poke(memAddress + 352, -1024);
	do Memory.poke(memAddress + 384, -256);
	do Memory.poke(memAddress + 416, -1024);
	do Memory.poke(memAddress + 448, -4096);
	do Memory.poke(memAddress + 480, -8192);
	return;
    }


    method boolean canMoveThrough(){
        return _moveThrough;
    }

    function Block getAir(){
        return air;
    }
}
